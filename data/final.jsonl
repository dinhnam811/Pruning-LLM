{"id":1,"slug":"two-sum","title":"Two Sum","difficulty":"Easy","content":"Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?","java":"import java.util.HashMap;\nimport java.util.Map;\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}","test_cases":[{"input":{"nums":[2,7,11,15],"target":9},"output":[0,1]},{"input":{"nums":[3,2,4],"target":6},"output":[1,2]},{"input":{"nums":[0,4,3,0],"target":0},"output":[0,3]}]}
{"id":2,"slug":"add-two-numbers","title":"Add Two Numbers","difficulty":"Medium","content":"You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n**Constraints:**\n\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.","java":"public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n    int carry = 0;\n\n    while (l1 != null || l2 != null || carry != 0) {\n        int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\n        carry = sum / 10;\n        current.next = new ListNode(sum % 10);\n        current = current.next;\n\n        if (l1 != null) l1 = l1.next;\n        if (l2 != null) l2 = l2.next;\n    }\n\n    return dummy.next;\n}","test_cases":[{"input":{"l1":[2,4,3],"l2":[5,6,4]},"output":[7,0,8]},{"input":{"l1":[0],"l2":[0]},"output":[0]},{"input":{"l1":[9,9,9],"l2":[1]},"output":[0,0,0,1]}]}
{"id":3,"slug":"longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","difficulty":"Medium","content":"Given a string `s`, find the length of the **longest** **substring** without repeating characters.\n\n**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of English letters, digits, symbols and spaces.","java":"import java.util.HashSet;\nimport java.util.Set;\n\npublic int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}","test_cases":[{"input":{"s":"abcabcbb"},"output":3},{"input":{"s":"bbbbb"},"output":1},{"input":{"s":""},"output":0}]}
{"id":4,"slug":"median-of-two-sorted-arrays","title":"Median of Two Sorted Arrays","difficulty":"Hard","content":"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.","java":"public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n    return 0;\n}","test_cases":[{"input":{"nums1":[1,3],"nums2":[2]},"output":2.0},{"input":{"nums1":[1,2],"nums2":[3,4]},"output":2.5}]}
{"id":5,"slug":"longest-palindromic-substring","title":"Longest Palindromic Substring","difficulty":"Medium","content":"Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.","java":"public String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n    int start = 0, maxLength = 1;\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1)) r++;\n        i = r;\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--; r++;\n        }\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n    return s.substring(start, start + maxLength);\n}","test_cases":[{"input":{"s":"babad"},"output":["bab","aba"]},{"input":{"s":"cbbd"},"output":["bb"]}]}
{"id":6,"slug":"zigzag-conversion","title":"Zigzag Conversion","difficulty":"Medium","content":"Write the code that will take a string and make this conversion given a number of rows.","java":"public String convert(String s, int numRows) {\n    if (numRows == 1 || numRows >= s.length()) return s;\n    StringBuilder[] rows = new StringBuilder[numRows];\n    for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();\n    int curRow = 0;\n    boolean goingDown = false;\n    for (char c : s.toCharArray()) {\n        rows[curRow].append(c);\n        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n    StringBuilder result = new StringBuilder();\n    for (StringBuilder row : rows) result.append(row);\n    return result.toString();\n}","test_cases":[{"input":{"s":"PAYPALISHIRING","numRows":3},"output":"PAHNAPLSIIGYIR"},{"input":{"s":"A","numRows":1},"output":"A"}]}
{"id":7,"slug":"reverse-integer","title":"Reverse Integer","difficulty":"Medium","content":"Given a signed 32-bit integer `x`, return `x` with its digits reversed.","java":"public int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}","test_cases":[{"input":{"x":123},"output":321},{"input":{"x":-123},"output":-321},{"input":{"x":1534236469},"output":0}]}
{"id":8,"slug":"string-to-integer-atoi","title":"String to Integer (atoi)","difficulty":"Medium","content":"Implement the myAtoi(string s) function.","java":"public int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int)(result * sign);\n}","test_cases":[{"input":{"s":"42"},"output":42},{"input":{"s":"   -42"},"output":-42},{"input":{"s":"words"},"output":0}]}
{"id":9,"slug":"palindrome-number","title":"Palindrome Number","difficulty":"Easy","content":"Given an integer `x`, return true if x is a palindrome.","java":"public boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}","test_cases":[{"input":{"x":121},"output":true},{"input":{"x":-121},"output":false},{"input":{"x":10},"output":false}]}
{"id":10,"slug":"regular-expression-matching","title":"Regular Expression Matching","difficulty":"Hard","content":"Implement regular expression matching with support for '.' and '*'.","java":"public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) dp[0][j] = true;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') dp[i][j] = dp[i - 1][j - 1];\n            else if (p.charAt(j - 1) == '*') dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n        }\n    }\n    return dp[m][n];\n}","test_cases":[{"input":{"s":"aa","p":"a"},"output":false},{"input":{"s":"aa","p":"a*"},"output":true},{"input":{"s":"ab","p":".*"},"output":true}]}
{"id":11,"slug":"container-with-most-water","title":"Container With Most Water","difficulty":null,"content":"You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.","java":"public int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) left++;\n        else right--;\n    }\n    return max_area;\n}","test_cases":[{"input":{"height":[1,8,6,2,5,4,8,3,7]},"output":49},{"input":{"height":[1,1]},"output":1}]}
{"id":12,"slug":"integer-to-roman","title":"Integer to Roman","difficulty":"Medium","content":"Given an integer, convert it to a roman numeral.","java":"public static String intToRoman(int num) {\n    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    String[] symbols = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n    StringBuilder sb = new StringBuilder();\n    for(int i=0;i<values.length;i++){\n        while(num>=values[i]){\n            num-=values[i];\n            sb.append(symbols[i]);\n        }\n    }\n    return sb.toString();\n}","test_cases":[{"input":{"num":3},"output":"III"},{"input":{"num":58},"output":"LVIII"},{"input":{"num":1994},"output":"MCMXCIV"}]}
{"id":13,"slug":"roman-to-integer","title":"Roman to Integer","difficulty":"Easy","content":"Given a roman numeral, convert it to an integer.","java":"public int romanToInt(String s) {\n    Map<Character, Integer> map = new HashMap<>();\n    map.put('I',1); map.put('V',5); map.put('X',10);\n    map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000);\n    int total=0, prev=0;\n    for(char c:s.toCharArray()){\n        int cur=map.get(c);\n        total += cur>prev ? cur-2*prev : cur;\n        prev=cur;\n    }\n    return total;\n}","test_cases":[{"input":{"s":"III"},"output":3},{"input":{"s":"LVIII"},"output":58},{"input":{"s":"MCMXCIV"},"output":1994}]}
{"id":14,"slug":"longest-common-prefix","title":"Longest Common Prefix","difficulty":"Easy","content":"Write a function to find the longest common prefix string amongst an array of strings.","java":"public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length(); i++) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);\n        }\n    }\n    return strs[0];\n}","test_cases":[{"input":{"strs":["flower","flow","flight"]},"output":"fl"},{"input":{"strs":["dog","racecar","car"]},"output":""}]}
{"id":15,"slug":"3sum","title":"3Sum","difficulty":"Medium","content":"Given an integer array nums, return all the triplets such that nums[i] + nums[j] + nums[k] == 0.","java":"public List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> res = new ArrayList<>();\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        int l = i + 1, r = nums.length - 1;\n        while (l < r) {\n            int sum = nums[i] + nums[l] + nums[r];\n            if (sum == 0) {\n                res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                while (l < r && nums[l] == nums[l + 1]) l++;\n                while (l < r && nums[r] == nums[r - 1]) r--;\n                l++; r--;\n            } else if (sum < 0) l++;\n            else r--;\n        }\n    }\n    return res;\n}","test_cases":[{"input":{"nums":[-1,0,1,2,-1,-4]},"output":[[-1,-1,2],[-1,0,1]]}]}
{"id":16,"slug":"3sum-closest","title":"3Sum Closest","difficulty":"Medium","content":"Find three integers in nums such that the sum is closest to target.","java":"public int threeSumClosest(int[] nums, int target) {\n    Arrays.sort(nums);\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.length - 2; i++) {\n        int l = i + 1, r = nums.length - 1;\n        while (l < r) {\n            int sum = nums[i] + nums[l] + nums[r];\n            if (Math.abs(target - sum) < Math.abs(target - closest)) closest = sum;\n            if (sum < target) l++;\n            else r--;\n        }\n    }\n    return closest;\n}","test_cases":[{"input":{"nums":[-1,2,1,-4],"target":1},"output":2}]}
{"id":17,"slug":"letter-combinations-of-a-phone-number","title":"Letter Combinations of a Phone Number","difficulty":"Medium","content":"Return all possible letter combinations that the number could represent.","java":"public List<String> letterCombinations(String digits) {\n    LinkedList<String> res = new LinkedList<>();\n    if (digits.isEmpty()) return res;\n    String[] map = {\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    res.add(\"\");\n    for (char d : digits.toCharArray()) {\n        while (res.peek().length() == digits.indexOf(d)) {\n            String cur = res.remove();\n            for (char c : map[d - '2'].toCharArray()) res.add(cur + c);\n        }\n    }\n    return res;\n}","test_cases":[{"input":{"digits":"23"},"output":["ad","ae","af","bd","be","bf","cd","ce","cf"]}]}
{"id":18,"slug":"4sum","title":"4Sum","difficulty":"Medium","content":"Return all unique quadruplets that sum to target.","java":"public List<List<Integer>> fourSum(int[] nums, int target) {\n    Arrays.sort(nums);\n    List<List<Integer>> res = new ArrayList<>();\n    for (int i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        for (int j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n            int l = j + 1, r = nums.length - 1;\n            while (l < r) {\n                long sum = (long) nums[i] + nums[j] + nums[l] + nums[r];\n                if (sum == target) {\n                    res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\n                    l++; r--;\n                    while (l < r && nums[l] == nums[l - 1]) l++;\n                    while (l < r && nums[r] == nums[r + 1]) r--;\n                } else if (sum < target) l++;\n                else r--;\n            }\n        }\n    }\n    return res;\n}","test_cases":[{"input":{"nums":[1,0,-1,0,-2,2],"target":0},"output":[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]}]}
{"id":19,"slug":"remove-nth-node-from-end-of-list","title":"Remove Nth Node From End of List","difficulty":"Medium","content":"Remove the nth node from the end of the list.","java":"public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode fast = head, slow = head;\n    for (int i = 0; i < n; i++) fast = fast.next;\n    if (fast == null) return head.next;\n    while (fast.next != null) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    slow.next = slow.next.next;\n    return head;\n}","test_cases":[{"input":{"list":[1,2,3,4,5],"n":2},"output":[1,2,3,5]}]}
{"id":20,"slug":"valid-parentheses","title":"Valid Parentheses","difficulty":"Easy","content":"Determine if the input string is valid.","java":"boolean isValid(String s) {\n    Stack<Character> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') st.push(c);\n        else {\n            if (st.isEmpty()) return false;\n            if (c == ')' && st.pop() != '(') return false;\n            if (c == '}' && st.pop() != '{') return false;\n            if (c == ']' && st.pop() != '[') return false;\n        }\n    }\n    return st.isEmpty();\n}","test_cases":[{"input":{"s":"()[]{}"},"output":true},{"input":{"s":"(]"},"output":false}]}
{"id":21,"slug":"merge-two-sorted-lists","title":"Merge Two Sorted Lists","difficulty":"Easy","content":"You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn _the head of the merged linked list_.","java":"public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list1 == null) return list2;\n    if (list2 == null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}","test_cases":[{"input":{"list1":[1,2,4],"list2":[1,3,4]},"output":[1,1,2,3,4,4]},{"input":{"list1":[],"list2":[]},"output":[]},{"input":{"list1":[],"list2":[0]},"output":[0]}]}
{"id":22,"slug":"generate-parentheses","title":"Generate Parentheses","difficulty":"Medium","content":"Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.","java":"public List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}","test_cases":[{"input":{"n":3},"output":["((()))","(()())","(())()","()(())","()()()"]},{"input":{"n":1},"output":["()"]}]}
{"id":23,"slug":"merge-k-sorted-lists","title":"Merge k Sorted Lists","difficulty":"Hard","content":"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\n_Merge all the linked-lists into one sorted linked-list and return it._","java":"public ListNode mergeKLists(ListNode[] lists) {\n    if(lists.length == 0) return null;\n    while(lists.length > 1){\n        List<ListNode> temp = new ArrayList<>();\n        temp.add(mergeTwoLists(lists[0],lists[1]));\n        temp.addAll(Arrays.asList(lists).subList(2, lists.length));\n        lists = temp.toArray(new ListNode[temp.size()]);\n    }\n    return lists[0];\n}","test_cases":[{"input":{"lists":[[1,4,5],[1,3,4],[2,6]]},"output":[1,1,2,3,4,4,5,6]},{"input":{"lists":[]},"output":null},{"input":{"lists":[[]]},"output":null}]}
{"id":24,"slug":"swap-nodes-in-pairs","title":"Swap Nodes in Pairs","difficulty":"Medium","content":"Given a linked list, swap every two adjacent nodes and return its head.","java":"public ListNode swapPairs(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode second = head.next;\n    head.next = swapPairs(second.next);\n    second.next = head;\n    return second;\n}","test_cases":[{"input":{"list":[1,2,3,4]},"output":[2,1,4,3]},{"input":{"list":[]},"output":[]},{"input":{"list":[1]},"output":[1]}]}
{"id":25,"slug":"reverse-nodes-in-k-group","title":"Reverse Nodes in k-Group","difficulty":"Hard","content":"Given the `head` of a linked list, reverse the nodes of the list `k` at a time.","java":"public ListNode reverseKGroup(ListNode head, int k) {\n    if (head == null || k == 1) return head;\n    int len = 0;\n    ListNode cur = head;\n    while (cur != null) { len++; cur = cur.next; }\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n    cur = head;\n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    return dummy.next;\n}","test_cases":[{"input":{"list":[1,2,3,4,5],"k":2},"output":[2,1,4,3,5]},{"input":{"list":[1,2,3,4,5],"k":3},"output":[3,2,1,4,5]}]}
{"id":26,"slug":"remove-duplicates-from-sorted-array","title":"Remove Duplicates from Sorted Array","difficulty":"Easy","content":"Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates in-place.","java":"public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}","test_cases":[{"input":{"nums":[1,1,2]},"output":{"k":2,"array":[1,2]}},{"input":{"nums":[0,0,1,1,1,2,2,3,3,4]},"output":{"k":5,"array":[0,1,2,3,4]}}]}
{"id":27,"slug":"remove-element","title":"Remove Element","difficulty":"Easy","content":"Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in-place.","java":"public int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}","test_cases":[{"input":{"nums":[3,2,2,3],"val":3},"output":{"k":2,"array":[2,2]}},{"input":{"nums":[0,1,2,2,3,0,4,2],"val":2},"output":{"k":5,"array":[0,1,3,0,4]}}]}
{"id":28,"slug":"find-the-index-of-the-first-occurrence-in-a-string","title":"Find the Index of the First Occurrence in a String","difficulty":"Easy","content":"Given two strings `needle` and `haystack`, return the index of the first occurrence.","java":"public int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    return haystack.indexOf(needle);\n}","test_cases":[{"input":{"haystack":"sadbutsad","needle":"sad"},"output":0},{"input":{"haystack":"leetcode","needle":"leeto"},"output":-1}]}
{"id":29,"slug":"divide-two-integers","title":"Divide Two Integers","difficulty":"Medium","content":"Divide two integers without using multiplication, division, and mod operator.","java":"public int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n    return ans * sign;\n}","test_cases":[{"input":{"dividend":10,"divisor":3},"output":3},{"input":{"dividend":7,"divisor":-3},"output":-2}]}
{"id":30,"slug":"substring-with-concatenation-of-all-words","title":"Substring with Concatenation of All Words","difficulty":"Hard","content":"Return the starting indices of all the concatenated substrings in s.","java":"public List<Integer> findSubstring(String s, String[] words) {\n    Map<String,Integer> map = new HashMap<>();\n    for(String w:words) map.put(w,map.getOrDefault(w,0)+1);\n    List<Integer> res = new ArrayList<>();\n    int wl = words[0].length(), total = wl * words.length;\n    for(int i=0;i<=s.length()-total;i++){\n        Map<String,Integer> seen = new HashMap<>();\n        int j=0;\n        for(;j<words.length;j++){\n            String sub = s.substring(i+j*wl,i+(j+1)*wl);\n            if(!map.containsKey(sub)) break;\n            seen.put(sub,seen.getOrDefault(sub,0)+1);\n            if(seen.get(sub)>map.get(sub)) break;\n        }\n        if(j==words.length) res.add(i);\n    }\n    return res;\n}","test_cases":[{"input":{"s":"barfoothefoobarman","words":["foo","bar"]},"output":[0,9]},{"input":{"s":"wordgoodgoodgoodbestword","words":["word","good","best","word"]},"output":[]}]}
